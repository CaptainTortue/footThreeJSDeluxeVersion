<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Jeu de Foot avec Three.js</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }
  </style>
</head>
<body>
<div id="container"></div>
<script src="https://cdn.socket.io/4.7.5/socket.io.min.js" integrity="sha384-2huaZvOR9iDzHqslqwpR87isEmrfxqyWOF7hr7BY6KG0+hVKLoEXMPUJw3ynWuhO" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script type="module">
  import { RGBELoader } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/loaders/RGBELoader.js';
  import { DRACOLoader } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/loaders/DRACOLoader.js';
  import { GLTFLoader } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/loaders/GLTFLoader.js';
  const clock = new THREE.Clock();
  const STEPS_PER_FRAME = 5;

  // Initialiser Socket.IO
  const socket = io("http://localhost:5000");

  // Initialiser la scène
  const scene = new THREE.Scene();
  scene.background = new THREE.Color( 0x333333 );
  scene.environment = new RGBELoader().load( '/textures/venice_sunset_1k.hdr' );
  scene.environment.mapping = THREE.EquirectangularReflectionMapping;
  //scene.fog = new THREE.Fog( 0x333333, 10, 15 );

  // Initialiser la caméra
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight);
  // set default camera angle
  camera.rotation.x = 1.5;
  camera.rotation.y = 0;
  camera.rotation.z = 0;
  let radius = 10;  // Distance constante entre la caméra et le cube
  let angleX = 15;   // Variable pour l'angle en X (horizontal)
  let angleY = 0;   // Variable pour l'angle en Y (vertical)

  //initialiser les var de la balle

  const sizeBall = 0.5;
  const gravity = -0.002;
  let velocity = new THREE.Vector3(0, 0, 0); //Pour la balle
  const damping = 0.98; // Pour réduire la vitesse
  const restitution = 0.8; 
  const carPushForce = 0.1;

  // Initialiser le rendu
  const renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);

  // Ajouter le rendu à la page
  const container = document.getElementById('container');
  container.appendChild(renderer.domElement);

  // Variables pour stocker les mouvements de la souris
  let isPointerLocked = false;
  // default position of the mouse mouvement and the camera
  let mouseDeltaX = 0, mouseDeltaY = -1.3;

  const grid = new THREE.GridHelper( 200, 400, 0xffffff, 0xffffff );
  grid.material.opacity = 0.2;
  grid.material.depthWrite = false;
  grid.material.transparent = true;
  // set grid angle
  grid.rotation.x = Math.PI / 2;
  // set grid position
  grid.position.z = -0.5;
  // position of th
  scene.add( grid );

  // Car
  const carMaterial = new THREE.MeshPhysicalMaterial( {
    color: 0xff0000, metalness: 1.0, roughness: 0.5, clearcoat: 1.0, clearcoatRoughness: 0.03
  } );

  const detailsCarMaterial = new THREE.MeshStandardMaterial( {
    color: 0xffffff, metalness: 1.0, roughness: 0.5
  } );

  const glassCarMaterial = new THREE.MeshPhysicalMaterial( {
    color: 0xffffff, metalness: 0.25, roughness: 0, transmission: 1.0
  } );

  const shadow = new THREE.TextureLoader().load( 'models/gltf/ferrari_ao.png' );

  const dracoLoader = new DRACOLoader();
  dracoLoader.setDecoderPath( 'jsm/libs/draco/gltf/' );

  let carModel;  // Declare a variable to hold the car model
  let wheels;  // Declare a variable to hold the wheels
  let moveAdvanceSpeed = 0;  // Variable to store the movement power of the car
  let maxAdvanceSpeed = .5;  // Maximum speed of the car
  let moveBackwardSpeed = 0;  // Variable to store the movement power of the car
  let maxBackwardSpeed = -.5;  // Maximum speed of the car
  let keyStates = {};
  // Liste des cubes joueurs et colliders
  const players = {};
  const colliders = {};

  let angleColision = 0;
  let pushForce = 0;


  /* socket */
  socket.on('players', (serverPlayers) => {
    for (let id in serverPlayers) {
      if (!players[id]) {
        players[id] = createPlayer(serverPlayers[id]);
      }
    }
  });
  // Suppression d'un joueur déconnecté
  socket.on('playerDisconnected', (id) => {
    if (players[id]) {
      scene.remove(players[id]);
      delete players[id];
      delete colliders[id];
    }
  });
  // Mise à jour de la position des joueurs
  socket.on('playerMoved', (user) => {
    if (players[user.id] !== undefined) {
      // Mettre à jour la position du joueur
      players[user.id].position.set(user.x, user.y, -.5);
      // Mettre à jour l'angle du joueur
      players[user.id].rotation.y = user.angle;
      colliders[user.id].setFromObject(players[user.id]); // Mettre à jour le collider
    }
  });

  // Colision
  socket.on('collision', (data) => {
    console.log(data.id, socket.id);
    if (players[data.id2] !== undefined && players[data.id] !== undefined && data.id2 == socket.id) {

      angleColision = data.angle;
      pushForce = data.pushForce * 1.25;

      /*
      // Déterminer la direction du déplacement
      let direction = new THREE.Vector3(Math.sin(-data.angle), Math.cos(-data.angle), 0);

      let moveVector = new THREE.Vector3();
      // Ajouter la vitesse dans la direction calculée
      moveVector.addScaledVector(direction, data.pushForce);

      // Appliquer le mouvement à la position actuelle
      carModel.position.add(moveVector);


      // Appliquer la force dans la direction opposée
      //const pushVector = oppositeDirection.multiplyScalar(data.pushForce*10);
      //moveVector.addScaledVector(direction, moveAdvanceSpeed + moveBackwardSpeed);

      // Modifier la position de la voiture (repoussée dans la direction opposée au mouvement de l'autre voiture)

      // Optionnel: Mettre à jour la position sur le serveur
      socket.emit('move', { x: carModel.position.x, y: carModel.position.y, angle: carModel.rotation.y, id: socket.id });
      */

    }
  });

  /* fin socket */


  function createPlayer(player) {
    console.log(player);
    const loaderPlayer = new GLTFLoader();
    loaderPlayer.setDRACOLoader( dracoLoader );
    loaderPlayer.load( 'models/gltf/ferrari.glb', function ( gltf ) {
      const carModelPlayer = gltf.scene.children[ 0 ];
      carModelPlayer.getObjectByName( 'body' ).material = carMaterial;
      carModelPlayer.getObjectByName( 'rim_fl' ).material = detailsCarMaterial;
      carModelPlayer.getObjectByName( 'rim_fr' ).material = detailsCarMaterial;
      carModelPlayer.getObjectByName( 'rim_rr' ).material = detailsCarMaterial;
      carModelPlayer.getObjectByName( 'rim_rl' ).material = detailsCarMaterial;
      carModelPlayer.getObjectByName( 'trim' ).material = detailsCarMaterial;
      carModelPlayer.getObjectByName( 'glass' ).material = glassCarMaterial;
      const wheelsPlayer = [];
      wheelsPlayer.push(
              carModel.getObjectByName( 'wheel_fl' ),
              carModel.getObjectByName( 'wheel_fr' ),
              carModel.getObjectByName( 'wheel_rl' ),
              carModel.getObjectByName( 'wheel_rr' )
      );
      // shadow
      const meshPlayer = new THREE.Mesh(
              new THREE.PlaneGeometry( 0.655 * 4, 1.3 * 4 ),
              new THREE.MeshBasicMaterial( {
                map: shadow, blending: THREE.MultiplyBlending, toneMapped: false, transparent: true
              } )
      );
      meshPlayer.rotation.x = - Math.PI / 2;
      meshPlayer.renderOrder = 2;
      carModelPlayer.add( meshPlayer );
      carModelPlayer.rotation.x = Math.PI / 2;
      carModelPlayer.position.z = -.5;
      carModelPlayer.position.x = player.x;
      carModelPlayer.position.y = player.y;
      // angle of the car
      carModelPlayer.rotation.y = player.angle;
      players[player.id] = carModelPlayer;
      colliders[player.id] = new THREE.Box3().setFromObject(carModelPlayer);
      scene.add( carModelPlayer );
    });
  }

  const loader = new GLTFLoader();
  loader.setDRACOLoader( dracoLoader );

  loader.load( 'models/gltf/ferrari.glb', function ( gltf ) {

    carModel = gltf.scene.children[ 0 ];

    carModel.getObjectByName( 'body' ).material = carMaterial;

    carModel.getObjectByName( 'rim_fl' ).material = detailsCarMaterial;
    carModel.getObjectByName( 'rim_fr' ).material = detailsCarMaterial;
    carModel.getObjectByName( 'rim_rr' ).material = detailsCarMaterial;
    carModel.getObjectByName( 'rim_rl' ).material = detailsCarMaterial;
    carModel.getObjectByName( 'trim' ).material = detailsCarMaterial;

    carModel.getObjectByName( 'glass' ).material = glassCarMaterial;
    wheels = [];
    wheels.push(
            carModel.getObjectByName( 'wheel_fl' ),
            carModel.getObjectByName( 'wheel_fr' ),
            carModel.getObjectByName( 'wheel_rl' ),
            carModel.getObjectByName( 'wheel_rr' )
    );

    // shadow
    const mesh = new THREE.Mesh(
            new THREE.PlaneGeometry( 0.655 * 4, 1.3 * 4 ),
            new THREE.MeshBasicMaterial( {
              map: shadow, blending: THREE.MultiplyBlending, toneMapped: false, transparent: true
            } )
    );
    mesh.rotation.x = - Math.PI / 2;
    mesh.renderOrder = 2;
    carModel.add( mesh );
    carModel.rotation.x = Math.PI / 2;
    carModel.position.z = -0.5;
    carModel.position.y = 0;
    carModel.position.x = (Math.random() * 50) - 25;

    scene.add( carModel );

    players[socket.id] = carModel;
    colliders[socket.id] = new THREE.Box3().setFromObject(carModel);
    // emit the new player to the server
    socket.emit('playerStartInfos', { x: carModel.position.x, y: carModel.position.y, angle: carModel.rotation.y, id: socket.id });
  } );

  function moveCar() {
    if (!carModel) return;
    let moveVector = new THREE.Vector3();
    // if player key advance is pressed, upgrad the advancePower
    if (keyStates['KeyW'] || keyStates['ArrowUp']) {
      moveAdvanceSpeed = (moveAdvanceSpeed + 0.001 > maxAdvanceSpeed) ? maxAdvanceSpeed : moveAdvanceSpeed + 0.001;
    } else {
      moveAdvanceSpeed = (moveAdvanceSpeed - 0.002 < 0) ? 0 : moveAdvanceSpeed - 0.002;
    }
    // if player key backward is pressed, upgrad the advancePower
    if (keyStates['KeyS'] || keyStates['ArrowDown']) {
      moveBackwardSpeed = (moveBackwardSpeed - 0.001 < maxBackwardSpeed) ? maxBackwardSpeed : moveBackwardSpeed - 0.001;
    } else {
      moveBackwardSpeed = (moveBackwardSpeed + 0.002 > 0) ? 0 : moveBackwardSpeed + 0.002;
    }
    let angle = carModel.rotation.y;
    // Calculer le vecteur de mouvement en fonction de l'angle de la voiture
    if (moveBackwardSpeed !== 0 || moveAdvanceSpeed !== 0) {
      // Récupérer l'angle actuel de la voiture

      // Déterminer la direction du déplacement
      let direction = new THREE.Vector3(Math.sin(-angle), Math.cos(-angle), 0);

      // Ajouter la vitesse dans la direction calculée
      moveVector.addScaledVector(direction, moveAdvanceSpeed + moveBackwardSpeed);

      // Appliquer le mouvement à la position actuelle
      carModel.position.add(moveVector);

      // Rotation de la voiture en fonction des touches gauche et droite
      if (keyStates['KeyD'] || keyStates['ArrowRight']) {
        carModel.rotation.y -= (moveAdvanceSpeed + moveBackwardSpeed) / 10;
      }
      if (keyStates['KeyA'] || keyStates['ArrowLeft']) {
        carModel.rotation.y += (moveAdvanceSpeed + moveBackwardSpeed) / 10;
      }
    }
    if (pushForce > 0) {
        // Déterminer la direction du déplacement
        let direction = new THREE.Vector3(Math.sin(-angleColision), Math.cos(-angleColision), 0);

        // Ajouter la vitesse dans la direction calculée
        moveVector.addScaledVector(direction, pushForce);

        // Appliquer le mouvement à la position actuelle
        carModel.position.add(moveVector);
        pushForce -= 0.01;
    }
    // Émettre la nouvelle position de la voiture au serveur
    socket.emit('move', { x: carModel.position.x, y: carModel.position.y, angle, id: socket.id });
    if (wheels) {
      for (let i = 0; i < wheels.length; i++) {
        wheels[i].rotation.x = moveAdvanceSpeed * Math.PI * 2;
      }
    }
  }
  function refreshCameraPosition() {
    if (carModel) {
      camera.position.x = carModel.position.x;
      camera.position.y = carModel.position.y;
      // Appliquer les mouvements de la souris à la caméra
      angleX = mouseDeltaX;
      angleY = mouseDeltaY;
      // Calculer la position de la caméra en coordonnées sphériques pour orbiter autour da la voiture
      camera.position.x += radius * Math.cos(angleY) * Math.sin(angleX);
      camera.position.y += radius * Math.sin(angleY);  // Déplacement vertical avec l'angle Y
      camera.position.z = radius * Math.cos(angleY) * Math.cos(angleX);
      camera.lookAt(carModel.position);  // Faire en sorte que la caméra regarde toujours la voiture
    }
  }

  //ball 

  const ballGeometry = new THREE.SphereGeometry(1, 32, 32);
  const ballMaterial = new THREE.MeshStandardMaterial({ color: 0xff4500, metalness: 0.5, roughness: 0.2 });
  const ball = new THREE.Mesh(ballGeometry, ballMaterial);
  ball.position.z = 19
  
  scene.add(ball);


  // Fonction pour capturer le pointeur lors du clic
  document.body.addEventListener('click', () => {
    if (!isPointerLocked) {
      document.body.requestPointerLock();
    }
  });

  // Suivi de la capture du pointeur
  document.addEventListener('pointerlockchange', () => {
    isPointerLocked = document.pointerLockElement === document.body;
  });

  // Événement pour capturer les mouvements de la souris quand le pointeur est verrouillé
  document.addEventListener('mousemove', (event) => {
    if (isPointerLocked) {
      mouseDeltaX += event.movementX * 0.002;  // Ajuster la sensibilité pour l'axe X
      mouseDeltaY -= event.movementY * 0.002;  // Ajuster la sensibilité pour l'axe Y

      // Limiter l'angle vertical pour éviter que la caméra ne passe en dessous du terrain
      mouseDeltaY = THREE.MathUtils.clamp(mouseDeltaY, -Math.PI / 2, Math.PI / 2);
      mouseDeltaX = THREE.MathUtils.clamp(mouseDeltaX, -Math.PI / 2, Math.PI / 2);
    }
  });

  function updateBallPhysics() {
    // Ajouter l'effet de gravité sur la vitesse verticale
    velocity.z += gravity;
  
    // Appliquer la vitesse à la position de la balle
    ball.position.add(velocity);
    
    // Gérer les collisions avec le terrain (rebonds sur l'axe Y)
    if (ball.position.z  - 0.5 <= 0) { // La balle touche le sol
      ball.position.z  = 0.5; // La balle ne passe pas sous le sol
      velocity.z  = -velocity.z  * restitution; // Inverser la vitesse et appliquer le coefficient de restitution
    }
  
    // Gérer la friction horizontale (ralentissement)
    velocity.x *= damping;
    velocity.y *= damping;
  }

  const ballBoundingSphere = new THREE.Sphere(ball.position, 1);
  let carBoundingBox = new THREE.Box3();


  function updateBoundingBox() {
      if (carModel) {
          carBoundingBox.setFromObject(carModel);
      }
  }

  // Collision detection function
  function detectCollisions() {
      updateBoundingBox();

      if (carBoundingBox.intersectsSphere(ballBoundingSphere)) {
          console.log('Collision Detected!');

          const collisionNormal = new THREE.Vector3().subVectors(ball.position, carModel.position).normalize();
          ball.position.add(collisionNormal.multiplyScalar(0.1));
      }

      // colision with ither cars
      for (let id in colliders) {
          if (carBoundingBox.intersectsBox(colliders[id]) && id !== socket.id) {
              console.log('Collision Detected with player ' + id);
              const tempvar = moveAdvanceSpeed;
              moveAdvanceSpeed = -moveBackwardSpeed;
              moveBackwardSpeed = -tempvar;
            /*const collisionNormal = new THREE.Vector3().subVectors(ball.position, carModel.position).normalize();
          ball.position.add(collisionNormal.multiplyScalar(0.1));

             */
            const collisionNormal = new THREE.Vector3().subVectors(carModel.position, players[id].position).normalize();
            carModel.position.add(collisionNormal.multiplyScalar(0.1));

              // emit the new position of the car to the server
              //socket.emit('move', { x: carModel.position.x, y: carModel.position.y, angle: carModel.rotation.y, id: socket.id });
              socket.emit('collision', { id: socket.id, id2: id, angle: carModel.rotation.y, pushForce: Math.abs(moveAdvanceSpeed + moveBackwardSpeed) });
          }
      }
  }

  const desiredFPS = 60;  // Le nombre d'images par seconde souhaité
  const timeStep = 1000 / desiredFPS;  // Temps en millisecondes entre chaque frame (16.67ms pour 60fps)
  let lastFrameTime = 0;

  // Fonction d'animation
  function animate(time) {
    const deltaTime = time - lastFrameTime;
    if (deltaTime >= timeStep) {
      lastFrameTime = time;
      moveCar();
      // effet de rotation
      ball.rotation.x += 0.01;
      ball.rotation.y += 0.01;

      updateBallPhysics()
      detectCollisions();
      refreshCameraPosition();

      renderer.render(scene, camera);
    }
    requestAnimationFrame(animate);
  }

  requestAnimationFrame(animate);

  document.addEventListener('keydown', (event) => {
    keyStates[ event.code ] = true;
    if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.code)) {
      event.preventDefault(); // Empêche le défilement de la page ou le mouvement de la caméra par défaut
    }
  });
  document.addEventListener( 'keyup', ( event ) => {
    keyStates[ event.code ] = false;
  });

  // Ajuster le rendu lors du redimensionnement de la fenêtre
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>
