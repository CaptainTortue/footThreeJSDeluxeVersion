<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Jeu de Foot avec Three.js</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }
  </style>
</head>
<body>
<div id="container"></div>
<script src="https://cdn.socket.io/4.7.5/socket.io.min.js" integrity="sha384-2huaZvOR9iDzHqslqwpR87isEmrfxqyWOF7hr7BY6KG0+hVKLoEXMPUJw3ynWuhO" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script type="module">
  import { RGBELoader } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/loaders/RGBELoader.js';
  import { DRACOLoader } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/loaders/DRACOLoader.js';
  import { GLTFLoader } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/loaders/GLTFLoader.js';
  const clock = new THREE.Clock();
  const STEPS_PER_FRAME = 5;

  // Initialiser Socket.IO
  const socket = io("http://localhost:5000");

  // Initialiser la scène
  const scene = new THREE.Scene();
  scene.background = new THREE.Color( 0x333333 );
  scene.environment = new RGBELoader().load( '/textures/venice_sunset_1k.hdr' );
 /* const textureLoader = new THREE.TextureLoader();
  const environmentTexture = textureLoader.load('/textures/ciel.png'); // Utilise le format converti (ex: PNG)

  // Assigner la texture à l'environnement de la scène
  scene.environment = environmentTexture;*/
  scene.environment.mapping = THREE.EquirectangularReflectionMapping;
  //scene.fog = new THREE.Fog( 0x333333, 10, 15 );

  // Initialiser la caméra
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight);
  // set default camera angle
  camera.rotation.x = 1.5;
  camera.rotation.y = 0;
  camera.rotation.z = 0;
  let radius = 10;  // Distance constante entre la caméra et le cube
  let angleX = 15;   // Variable pour l'angle en X (horizontal)
  let angleY = 0;   // Variable pour l'angle en Y (vertical)

  // Initialiser le rendu
  const renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);

  // Ajouter le rendu à la page
  const container = document.getElementById('container');
  container.appendChild(renderer.domElement);

  // Variables pour stocker les mouvements de la souris
  let isPointerLocked = false;
  // default position of the mouse mouvement and the camera
  let mouseDeltaX = 0, mouseDeltaY = -1.3;

  const grid = new THREE.GridHelper( 200, 400, 0xffffff, 0xffffff );
  grid.material.opacity = 0.2;
  grid.material.depthWrite = false;
  grid.material.transparent = true;
  // set grid angle
  grid.rotation.x = Math.PI / 2;
  // set grid position
  grid.position.z = -0.5;
  // position of th
  scene.add( grid );

  // ajouter un plateau d'exemple, comme un mur
  const wall = new THREE.BoxGeometry( 10, 2, 0.5 );
  const wallMaterial = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
  const wallMesh = new THREE.Mesh( wall, wallMaterial );
  wallMesh.position.z = -0.25;
  scene.add( wallMesh );


  // Car
  const carMaterial = new THREE.MeshPhysicalMaterial( {
    color: 0xff0000, metalness: 1.0, roughness: 0.5, clearcoat: 1.0, clearcoatRoughness: 0.03
  } );


  const detailsCarMaterial = new THREE.MeshStandardMaterial( {
    color: 0xffffff, metalness: 1.0, roughness: 0.5
  } );

  const glassCarMaterial = new THREE.MeshPhysicalMaterial( {
    color: 0xffffff, metalness: 0.25, roughness: 0, transmission: 1.0
  } );

  const shadow = new THREE.TextureLoader().load( 'models/gltf/ferrari_ao.png' );

  const dracoLoader = new DRACOLoader();
  dracoLoader.setDecoderPath( 'jsm/libs/draco/gltf/' );

  let carModel;  // Declare a variable to hold the car model
  let wheels;  // Declare a variable to hold the wheels
  let moveAdvanceSpeed = 0;  // Variable to store the movement power of the car
  let maxAdvanceSpeed = .1;  // Maximum speed of the car
  let moveBackwardSpeed = 0;  // Variable to store the movement power of the car
  let maxBackwardSpeed = -.1;  // Maximum speed of the car

  // Liste des cubes joueurs et colliders
  const players = {};
  const colliders = {};
  let keyStates = {};

  /* socket */
  socket.on('players', (serverPlayers) => {
    for (let id in serverPlayers) {
      if (!players[id]) {
        players[id] = createPlayer(serverPlayers[id]);
      }
    }
  });

  // Suppression d'un joueur déconnecté
  socket.on('playerDisconnected', (id) => {
    if (players[id]) {
        scene.remove(players[id]);
        delete players[id];
    }
  });

  // Mise à jour de la position des joueurs
  socket.on('playerMoved', (user) => {
    if (players[user.id] !== undefined) {
      // Mettre à jour la position du joueur
      players[user.id].position.set(user.x, user.y, -.5);
      // Mettre à jour l'angle du joueur
      players[user.id].rotation.y = user.angle;
      colliders[user.id].setFromObject(players[user.id]); // Mettre à jour le collider
    }
  });

  /* fin socket */

  function createPlayer(player) {
    console.log(player);
    const loaderPlayer = new GLTFLoader();
    loaderPlayer.setDRACOLoader( dracoLoader );

    loaderPlayer.load( 'models/gltf/ferrari.glb', function ( gltf ) {
        const carModelPlayer = gltf.scene.children[ 0 ];

        carModelPlayer.getObjectByName( 'body' ).material = carMaterial;

        carModelPlayer.getObjectByName( 'rim_fl' ).material = detailsCarMaterial;
        carModelPlayer.getObjectByName( 'rim_fr' ).material = detailsCarMaterial;
        carModelPlayer.getObjectByName( 'rim_rr' ).material = detailsCarMaterial;
        carModelPlayer.getObjectByName( 'rim_rl' ).material = detailsCarMaterial;
        carModelPlayer.getObjectByName( 'trim' ).material = detailsCarMaterial;

        carModelPlayer.getObjectByName( 'glass' ).material = glassCarMaterial;
        const wheelsPlayer = [];
        wheelsPlayer.push(
                carModel.getObjectByName( 'wheel_fl' ),
                carModel.getObjectByName( 'wheel_fr' ),
                carModel.getObjectByName( 'wheel_rl' ),
                carModel.getObjectByName( 'wheel_rr' )
        );

        // shadow
        const meshPlayer = new THREE.Mesh(
                new THREE.PlaneGeometry( 0.655 * 4, 1.3 * 4 ),
                new THREE.MeshBasicMaterial( {
                  map: shadow, blending: THREE.MultiplyBlending, toneMapped: false, transparent: true
                } )
        );
        meshPlayer.rotation.x = - Math.PI / 2;
        meshPlayer.renderOrder = 2;
        carModelPlayer.add( meshPlayer );
        carModelPlayer.rotation.x = Math.PI / 2;
        carModelPlayer.position.z = -.5;
        carModelPlayer.position.x = player.x;
        carModelPlayer.position.y = player.y;
        // angle of the car
        carModelPlayer.rotation.y = player.angle;
        players[player.id] = carModelPlayer;
        colliders[player.id] = new THREE.Box3().setFromObject(carModelPlayer);
        scene.add( carModelPlayer );
    });
  }

  const loader = new GLTFLoader();
  loader.setDRACOLoader( dracoLoader );

  loader.load( 'models/gltf/ferrari.glb', function ( gltf ) {

    carModel = gltf.scene.children[ 0 ];

    carModel.getObjectByName( 'body' ).material = carMaterial;

    carModel.getObjectByName( 'rim_fl' ).material = detailsCarMaterial;
    carModel.getObjectByName( 'rim_fr' ).material = detailsCarMaterial;
    carModel.getObjectByName( 'rim_rr' ).material = detailsCarMaterial;
    carModel.getObjectByName( 'rim_rl' ).material = detailsCarMaterial;
    carModel.getObjectByName( 'trim' ).material = detailsCarMaterial;

    carModel.getObjectByName( 'glass' ).material = glassCarMaterial;
    wheels = [];
    wheels.push(
            carModel.getObjectByName( 'wheel_fl' ),
            carModel.getObjectByName( 'wheel_fr' ),
            carModel.getObjectByName( 'wheel_rl' ),
            carModel.getObjectByName( 'wheel_rr' )
    );

    // shadow
    const mesh = new THREE.Mesh(
            new THREE.PlaneGeometry( 0.655 * 4, 1.3 * 4 ),
            new THREE.MeshBasicMaterial( {
              map: shadow, blending: THREE.MultiplyBlending, toneMapped: false, transparent: true
            } )
    );
    mesh.rotation.x = - Math.PI / 2;
    mesh.renderOrder = 2;
    carModel.add( mesh );
    carModel.rotation.x = Math.PI / 2;
    carModel.position.z = -0.5;
    carModel.position.y = 0;
    carModel.position.x = (Math.random() * 50) - 25;

    scene.add( carModel );

    players[socket.id] = carModel;
    // emit the new player to the server
    socket.emit('playerStartInfos', { x: carModel.position.x, y: carModel.position.y, angle: carModel.rotation.y, id: socket.id });
  } );

  // Fonction pour capturer le pointeur lors du clic
  document.body.addEventListener('click', () => {
    if (!isPointerLocked) {
      document.body.requestPointerLock();
    }
  });

  // Suivi de la capture du pointeur
  document.addEventListener('pointerlockchange', () => {
    isPointerLocked = document.pointerLockElement === document.body;
  });

  // Événement pour capturer les mouvements de la souris quand le pointeur est verrouillé
  document.addEventListener('mousemove', (event) => {
    if (isPointerLocked) {
      mouseDeltaX += event.movementX * 0.002;  // Ajuster la sensibilité pour l'axe X
      mouseDeltaY -= event.movementY * 0.002;  // Ajuster la sensibilité pour l'axe Y

      // Limiter l'angle vertical pour éviter que la caméra ne passe en dessous du terrain
      mouseDeltaY = THREE.MathUtils.clamp(mouseDeltaY, -Math.PI / 2, Math.PI / 2);
      mouseDeltaX = THREE.MathUtils.clamp(mouseDeltaX, -Math.PI / 2, Math.PI / 2);
    }
  });

  function moveCar() {
    // if player key advance is pressed, upgrad the advancePower
    if (keyStates['KeyW'] || keyStates['ArrowUp']) {
      moveAdvanceSpeed = (moveAdvanceSpeed + 0.0001 > maxAdvanceSpeed) ? maxAdvanceSpeed : moveAdvanceSpeed + 0.0001;
    } else {
      moveAdvanceSpeed = (moveAdvanceSpeed - 0.0002 < 0) ? 0 : moveAdvanceSpeed - 0.0002;
    }

    // if player key backward is pressed, upgrad the advancePower
    if (keyStates['KeyS'] || keyStates['ArrowDown']) {
      moveBackwardSpeed = (moveBackwardSpeed - 0.0001 < maxBackwardSpeed) ? maxBackwardSpeed : moveBackwardSpeed - 0.0001;
    } else {
      moveBackwardSpeed = (moveBackwardSpeed + 0.0002 > 0) ? 0 : moveBackwardSpeed + 0.0002;
    }

    if (moveBackwardSpeed != 0 || moveAdvanceSpeed != 0) {
      // advance the car
      // get angle of the car
      let angle = carModel.rotation.y;
      // get the x and y position of the car
      let x = carModel.position.x;
      let y = carModel.position.y;
      // calculate the new position of the car, don't forget to add the moveBackwardSpeed and to set the angle to negative
      x += Math.sin(-angle) * (moveAdvanceSpeed + moveBackwardSpeed);
      y += Math.cos(-angle) * (moveAdvanceSpeed + moveBackwardSpeed);
      // set the new position of the car
      carModel.position.x = x;
      carModel.position.y = y;
      // emit the new position of the car to the server
      socket.emit('move', { x, y, angle, id: socket.id });

      // if player key right is pressed, rotate the car to the right
      if (keyStates['KeyD'] || keyStates['ArrowRight']) {
        carModel.rotation.y -= (moveAdvanceSpeed + moveBackwardSpeed) / 10;
      }

      // if player key left is pressed, rotate the car to the left
      if (keyStates['KeyA'] || keyStates['ArrowLeft']) {
        carModel.rotation.y += (moveAdvanceSpeed + moveBackwardSpeed) / 10;
      }
    }

    if (wheels) {
      for (let i = 0; i < wheels.length; i++) {

        wheels[i].rotation.x = moveAdvanceSpeed * Math.PI * 2;

      }
    }
  }

  function refreshCameraPosition() {

    if (carModel) {
      camera.position.x = carModel.position.x;
      camera.position.y = carModel.position.y;

      // Appliquer les mouvements de la souris à la caméra
      angleX = mouseDeltaX;
      angleY = mouseDeltaY;

      // Calculer la position de la caméra en coordonnées sphériques pour orbiter autour da la voiture
      camera.position.x += radius * Math.cos(angleY) * Math.sin(angleX);
      camera.position.y += radius * Math.sin(angleY);  // Déplacement vertical avec l'angle Y
      camera.position.z = radius * Math.cos(angleY) * Math.cos(angleX);

      camera.lookAt(carModel.position);  // Faire en sorte que la caméra regarde toujours la voiture
    }
  }

  // Fonction d'animation
  function animate() {
    requestAnimationFrame(animate);

    moveCar()

    /*if (carModel) {
      // Appliquer les mouvements de la souris à la caméra
      angleX = mouseDeltaX;
      angleY = mouseDeltaY;

      // Calculer la position de la caméra en coordonnées sphériques pour orbiter autour da la voiture
      camera.position.x = radius * Math.cos(angleY) * Math.sin(angleX);
      camera.position.y = radius * Math.sin(angleY);  // Déplacement vertical avec l'angle Y
      camera.position.z = radius * Math.cos(angleY) * Math.cos(angleX);

      camera.lookAt(carModel.position);  // Faire en sorte que la caméra regarde toujours la voiture
    }*/
    refreshCameraPosition();

    renderer.render(scene, camera);
  }

  animate();

  // Ajuster le rendu lors du redimensionnement de la fenêtre
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  document.addEventListener('keydown', (event) => {
    keyStates[ event.code ] = true;
    if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.code)) {
      event.preventDefault(); // Empêche le défilement de la page ou le mouvement de la caméra par défaut
    }
  });

  document.addEventListener( 'keyup', ( event ) => {
    keyStates[ event.code ] = false;
  });
</script>
</body>
</html>
