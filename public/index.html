<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Jeu de Foot avec Three.js</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }
  </style>
</head>
<body>
<div id="container"></div>
<script src="https://cdn.socket.io/4.7.5/socket.io.min.js" integrity="sha384-2huaZvOR9iDzHqslqwpR87isEmrfxqyWOF7hr7BY6KG0+hVKLoEXMPUJw3ynWuhO" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script type="module">
  import { RGBELoader } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/loaders/RGBELoader.js';
  import { DRACOLoader } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/loaders/DRACOLoader.js';
  import { GLTFLoader } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/loaders/GLTFLoader.js';
  const clock = new THREE.Clock();
  const STEPS_PER_FRAME = 5;

  const grassShader = {
    vert: `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        vec3 pos = position;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
      }
    `,
    frag: `
      uniform sampler2D textures[2];
      uniform float iTime;
      varying vec2 vUv;
      
      void main() {
        vec3 grassColor = texture2D(textures[0], vUv).rgb;
        vec3 cloudColor = texture2D(textures[1], vUv * 0.1).rgb; // Adding cloud effect
        gl_FragColor = vec4(grassColor * 0.5 + cloudColor * 0.5, 1.0);
      }
    `
  };

  // Initialiser Socket.IO
  const socket = io("http://localhost:5000");

  // Initialiser la scène
  const scene = new THREE.Scene();
  scene.background = new THREE.Color( 0x333333 );
  scene.environment = new RGBELoader().load( '/textures/venice_sunset_1k.hdr' );
  scene.environment.mapping = THREE.EquirectangularReflectionMapping;
  //scene.fog = new THREE.Fog( 0x333333, 10, 15 );

  // Initialiser la caméra
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight);
  // set default camera angle
  camera.rotation.x = 1.5;
  camera.rotation.y = 0;
  camera.rotation.z = 0;
  let radius = 10;  // Distance constante entre la caméra et le cube
  let angleX = 15;   // Variable pour l'angle en X (horizontal)
  let angleY = 0;   // Variable pour l'angle en Y (vertical)

  //initialiser les var de la balle

  const sizeBall = 0.5;
  const gravity = -0.002;
  let velocity = new THREE.Vector3(0, 0, 0); //Pour la balle
  const damping = 0.98; // Pour réduire la vitesse
  const restitution = 0.8; 
  const carPushForce = 0.1;

  // Initialiser le rendu
  const renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);

  // Ajouter le rendu à la page
  const container = document.getElementById('container');
  container.appendChild(renderer.domElement);

  // Variables pour stocker les mouvements de la souris
  let isPointerLocked = false;
  // default position of the mouse mouvement and the camera
  let mouseDeltaX = 0, mouseDeltaY = -1.3;

  const grid = new THREE.GridHelper( 200, 400, 0xffffff, 0xffffff );
  grid.material.opacity = 0.2;
  grid.material.depthWrite = false;
  grid.material.transparent = true;
  // set grid angle
  grid.rotation.x = Math.PI / 2;
  // set grid position
  grid.position.z = -0.5;
  // position of th
  scene.add( grid );

  //Grass Field
  // Parameters for Grass Field
  const PLANE_SIZE_Z = 200;
  const PLANE_SIZE_X = 200;
  const BLADE_COUNT = 100000; // Reduced for performance
  const BLADE_WIDTH = 0.1;
  const BLADE_HEIGHT = 0.2;
  const BLADE_HEIGHT_VARIATION = 0.4;

  // Grass Textures
  const grassTexture = new THREE.TextureLoader().load('textures/grass.jpg');
  const cloudTexture = new THREE.TextureLoader().load('textures/cloud.jpg');
  cloudTexture.wrapS = cloudTexture.wrapT = THREE.RepeatWrapping;

  // Time Uniform
  const timeUniform = { type: 'f', value: 0.0 };
  const grassUniforms = {
    textures: { value: [grassTexture, cloudTexture] },
    iTime: timeUniform
  };

  const grassMaterial = new THREE.ShaderMaterial({
    uniforms: grassUniforms,
    vertexShader: grassShader.vert,
    fragmentShader: grassShader.frag,
    side: THREE.DoubleSide
  });

  generateField();

  function generateField() {
    const positions = [];
    const uvs = [];
    const indices = [];
    const colors = [];

    for (let i = 0; i < BLADE_COUNT; i++) {
      const pos = new THREE.Vector3(
        (Math.random() - 0.5) * PLANE_SIZE_X,
        (Math.random() - 0.5) * PLANE_SIZE_Z
      ,0 -0.5
      );

      const uv = [(pos.x + PLANE_SIZE_X / 2) / PLANE_SIZE_X, (pos.z + PLANE_SIZE_Z / 2) / PLANE_SIZE_Z];
      const blade = generateBlade(pos, i * 5, uv);

      blade.verts.forEach(vert => {
        positions.push(...vert.pos);
        uvs.push(...vert.uv);
        colors.push(...vert.color);
      });
      blade.indices.forEach(indice => indices.push(indice));
    }

    function generateBlade(center, vArrOffset, uv) {
      const height = BLADE_HEIGHT + (Math.random() * BLADE_HEIGHT_VARIATION);
      const yaw = Math.random() * Math.PI * 2;
      const yawUnitVec = new THREE.Vector3(Math.sin(yaw), 0, -Math.cos(yaw));
  
      const bl = center.clone().add(yawUnitVec.clone().multiplyScalar(BLADE_WIDTH / 2));
      const br = center.clone().add(yawUnitVec.clone().multiplyScalar(-BLADE_WIDTH / 2));
      const tl = center.clone().add(yawUnitVec.clone().multiplyScalar(BLADE_WIDTH / 4));
      const tr = center.clone().add(yawUnitVec.clone().multiplyScalar(-BLADE_WIDTH / 4));
      const tc = center.clone().add(new THREE.Vector3(0, 0,height));
  
      tl.z += height / 2; // Ajustez la hauteur
      tr.z += height / 2; // Ajustez la hauteur
      tc.z += height; // Ajustez la hauteur
  
      const verts = [
        { pos: bl.toArray(), uv: uv, color: [0, 0, 0] },
        { pos: br.toArray(), uv: uv, color: [0, 0, 0] },
        { pos: tr.toArray(), uv: uv, color: [0.5, 0.5, 0.5] },
        { pos: tl.toArray(), uv: uv, color: [0.5, 0.5, 0.5] },
        { pos: tc.toArray(), uv: uv, color: [1, 1, 1] }
      ];
  
      const indices = [
        vArrOffset, vArrOffset + 1, vArrOffset + 2,
        vArrOffset + 2, vArrOffset + 4, vArrOffset + 3,
        vArrOffset + 3, vArrOffset, vArrOffset + 2
      ];
  
      return { verts, indices };
    }
    const geom = new THREE.BufferGeometry();
    geom.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positions), 3));
    geom.setAttribute('uv', new THREE.BufferAttribute(new Float32Array(uvs), 2));
    geom.setAttribute('color', new THREE.BufferAttribute(new Float32Array(colors), 3));
    geom.setIndex(indices);
    geom.computeVertexNormals();

    const mesh = new THREE.Mesh(geom, grassMaterial);
    scene.add(mesh);
  }

  // Car
  const carMaterial = new THREE.MeshPhysicalMaterial( {
    color: 0xff0000, metalness: 1.0, roughness: 0.5, clearcoat: 1.0, clearcoatRoughness: 0.03
  } );

  const detailsCarMaterial = new THREE.MeshStandardMaterial( {
    color: 0xffffff, metalness: 1.0, roughness: 0.5
  } );

  const glassCarMaterial = new THREE.MeshPhysicalMaterial( {
    color: 0xffffff, metalness: 0.25, roughness: 0, transmission: 1.0
  } );

  const shadow = new THREE.TextureLoader().load( 'models/gltf/ferrari_ao.png' );

  const dracoLoader = new DRACOLoader();
  dracoLoader.setDecoderPath( 'jsm/libs/draco/gltf/' );

  let carModel;  // Declare a variable to hold the car model
  let wheels;  // Declare a variable to hold the wheels
  let moveAdvanceSpeed = 0;  // Variable to store the movement power of the car
  let maxAdvanceSpeed = .1;  // Maximum speed of the car
  let moveBackwardSpeed = 0;  // Variable to store the movement power of the car
  let maxBackwardSpeed = -.1;  // Maximum speed of the car
  let keyStates = {};
  // Liste des cubes joueurs et colliders
  const players = {};
  const colliders = {};


  /* socket */
  socket.on('players', (serverPlayers) => {
    for (let id in serverPlayers) {
      if (!players[id]) {
        players[id] = createPlayer(serverPlayers[id]);
      }
    }
  });
  // Suppression d'un joueur déconnecté
  socket.on('playerDisconnected', (id) => {
    if (players[id]) {
      scene.remove(players[id]);
      delete players[id];
    }
  });
  // Mise à jour de la position des joueurs
  socket.on('playerMoved', (user) => {
    if (players[user.id] !== undefined) {
      // Mettre à jour la position du joueur
      players[user.id].position.set(user.x, user.y, -.5);
      // Mettre à jour l'angle du joueur
      players[user.id].rotation.y = user.angle;
      colliders[user.id].setFromObject(players[user.id]); // Mettre à jour le collider
    }
  });
  /* fin socket */
  function createPlayer(player) {
    console.log(player);
    const loaderPlayer = new GLTFLoader();
    loaderPlayer.setDRACOLoader( dracoLoader );
    loaderPlayer.load( 'models/gltf/ferrari.glb', function ( gltf ) {
      const carModelPlayer = gltf.scene.children[ 0 ];
      carModelPlayer.getObjectByName( 'body' ).material = carMaterial;
      carModelPlayer.getObjectByName( 'rim_fl' ).material = detailsCarMaterial;
      carModelPlayer.getObjectByName( 'rim_fr' ).material = detailsCarMaterial;
      carModelPlayer.getObjectByName( 'rim_rr' ).material = detailsCarMaterial;
      carModelPlayer.getObjectByName( 'rim_rl' ).material = detailsCarMaterial;
      carModelPlayer.getObjectByName( 'trim' ).material = detailsCarMaterial;
      carModelPlayer.getObjectByName( 'glass' ).material = glassCarMaterial;
      const wheelsPlayer = [];
      wheelsPlayer.push(
              carModel.getObjectByName( 'wheel_fl' ),
              carModel.getObjectByName( 'wheel_fr' ),
              carModel.getObjectByName( 'wheel_rl' ),
              carModel.getObjectByName( 'wheel_rr' )
      );
      // shadow
      const meshPlayer = new THREE.Mesh(
              new THREE.PlaneGeometry( 0.655 * 4, 1.3 * 4 ),
              new THREE.MeshBasicMaterial( {
                map: shadow, blending: THREE.MultiplyBlending, toneMapped: false, transparent: true
              } )
      );
      meshPlayer.rotation.x = - Math.PI / 2;
      meshPlayer.renderOrder = 2;
      carModelPlayer.add( meshPlayer );
      carModelPlayer.rotation.x = Math.PI / 2;
      carModelPlayer.position.z = -.5;
      carModelPlayer.position.x = player.x;
      carModelPlayer.position.y = player.y;
      // angle of the car
      carModelPlayer.rotation.y = player.angle;
      players[player.id] = carModelPlayer;
      colliders[player.id] = new THREE.Box3().setFromObject(carModelPlayer);
      scene.add( carModelPlayer );
    });
  }

  const loader = new GLTFLoader();
  loader.setDRACOLoader( dracoLoader );

  loader.load( 'models/gltf/ferrari.glb', function ( gltf ) {

    carModel = gltf.scene.children[ 0 ];

    carModel.getObjectByName( 'body' ).material = carMaterial;

    carModel.getObjectByName( 'rim_fl' ).material = detailsCarMaterial;
    carModel.getObjectByName( 'rim_fr' ).material = detailsCarMaterial;
    carModel.getObjectByName( 'rim_rr' ).material = detailsCarMaterial;
    carModel.getObjectByName( 'rim_rl' ).material = detailsCarMaterial;
    carModel.getObjectByName( 'trim' ).material = detailsCarMaterial;

    carModel.getObjectByName( 'glass' ).material = glassCarMaterial;
    wheels = [];
    wheels.push(
            carModel.getObjectByName( 'wheel_fl' ),
            carModel.getObjectByName( 'wheel_fr' ),
            carModel.getObjectByName( 'wheel_rl' ),
            carModel.getObjectByName( 'wheel_rr' )
    );

    // shadow
    const mesh = new THREE.Mesh(
            new THREE.PlaneGeometry( 0.655 * 4, 1.3 * 4 ),
            new THREE.MeshBasicMaterial( {
              map: shadow, blending: THREE.MultiplyBlending, toneMapped: false, transparent: true
            } )
    );
    mesh.rotation.x = - Math.PI / 2;
    mesh.renderOrder = 2;
    carModel.add( mesh );
    carModel.rotation.x = Math.PI / 2;
    carModel.position.z = -0.5;
    carModel.position.y = 0;
    carModel.position.x = (Math.random() * 50) - 25;

    scene.add( carModel );

    players[socket.id] = carModel;
    // emit the new player to the server
    socket.emit('playerStartInfos', { x: carModel.position.x, y: carModel.position.y, angle: carModel.rotation.y, id: socket.id });
  } );

  function moveCar() {
    // if player key advance is pressed, upgrad the advancePower
    if (keyStates['KeyW'] || keyStates['ArrowUp']) {
      moveAdvanceSpeed = (moveAdvanceSpeed + 0.2 > maxAdvanceSpeed) ? maxAdvanceSpeed : moveAdvanceSpeed + 0.2;
    } else {
      moveAdvanceSpeed = (moveAdvanceSpeed - 0.0002 < 0) ? 0 : moveAdvanceSpeed - 0.0002;
    }
    // if player key backward is pressed, upgrad the advancePower
    if (keyStates['KeyS'] || keyStates['ArrowDown']) {
      moveBackwardSpeed = (moveBackwardSpeed - 0.0001 < maxBackwardSpeed) ? maxBackwardSpeed : moveBackwardSpeed - 0.0001;
    } else {
      moveBackwardSpeed = (moveBackwardSpeed + 0.0002 > 0) ? 0 : moveBackwardSpeed + 0.0002;
    }
    if (moveBackwardSpeed != 0 || moveAdvanceSpeed != 0) {
      // advance the car
      // get angle of the car
      let angle = carModel.rotation.y;
      // get the x and y position of the car
      let x = carModel.position.x;
      let y = carModel.position.y;
      // calculate the new position of the car, don't forget to add the moveBackwardSpeed and to set the angle to negative
      x += Math.sin(-angle) * (moveAdvanceSpeed + moveBackwardSpeed);
      y += Math.cos(-angle) * (moveAdvanceSpeed + moveBackwardSpeed);
      // set the new position of the car
      carModel.position.x = x;
      carModel.position.y = y;
      // emit the new position of the car to the server
      socket.emit('move', { x, y, angle, id: socket.id });

      // if player key right is pressed, rotate the car to the right
      if (keyStates['KeyD'] || keyStates['ArrowRight']) {
        carModel.rotation.y -= (moveAdvanceSpeed + moveBackwardSpeed) / 10;
      }
      // if player key left is pressed, rotate the car to the left
      if (keyStates['KeyA'] || keyStates['ArrowLeft']) {
        carModel.rotation.y += (moveAdvanceSpeed + moveBackwardSpeed) / 10;
      }
    }
    if (wheels) {
      for (let i = 0; i < wheels.length; i++) {
        wheels[i].rotation.x = moveAdvanceSpeed * Math.PI * 2;
      }
    }
  }
  function refreshCameraPosition() {
    if (carModel) {
      camera.position.x = carModel.position.x;
      camera.position.y = carModel.position.y;
      // Appliquer les mouvements de la souris à la caméra
      angleX = mouseDeltaX;
      angleY = mouseDeltaY;
      // Calculer la position de la caméra en coordonnées sphériques pour orbiter autour da la voiture
      camera.position.x += radius * Math.cos(angleY) * Math.sin(angleX);
      camera.position.y += radius * Math.sin(angleY);  // Déplacement vertical avec l'angle Y
      camera.position.z = radius * Math.cos(angleY) * Math.cos(angleX);
      camera.lookAt(carModel.position);  // Faire en sorte que la caméra regarde toujours la voiture
    }
  }

  //ball 

  const ballGeometry = new THREE.SphereGeometry(1, 32, 32);
  const ballMaterial = new THREE.MeshStandardMaterial({ color: 0xff4500, metalness: 0.5, roughness: 0.2 });
  const ball = new THREE.Mesh(ballGeometry, ballMaterial);
  ball.position.z = 19
  
  scene.add(ball);


  // Fonction pour capturer le pointeur lors du clic
  document.body.addEventListener('click', () => {
    if (!isPointerLocked) {
      document.body.requestPointerLock();
    }
  });

  // Suivi de la capture du pointeur
  document.addEventListener('pointerlockchange', () => {
    isPointerLocked = document.pointerLockElement === document.body;
  });

  // Événement pour capturer les mouvements de la souris quand le pointeur est verrouillé
  document.addEventListener('mousemove', (event) => {
    if (isPointerLocked) {
      mouseDeltaX += event.movementX * 0.002;  // Ajuster la sensibilité pour l'axe X
      mouseDeltaY -= event.movementY * 0.002;  // Ajuster la sensibilité pour l'axe Y

      // Limiter l'angle vertical pour éviter que la caméra ne passe en dessous du terrain
      mouseDeltaY = THREE.MathUtils.clamp(mouseDeltaY, -Math.PI / 2, Math.PI / 2);
      mouseDeltaX = THREE.MathUtils.clamp(mouseDeltaX, -Math.PI / 2, Math.PI / 2);
    }
  });
  function updateBallPhysics() {
    // Ajouter l'effet de gravité sur la vitesse verticale
    velocity.z += gravity;
  
    // Appliquer la vitesse à la position de la balle
    ball.position.add(velocity);
    
    // Gérer les collisions avec le terrain (rebonds sur l'axe Y)
    if (ball.position.z  - 0.5 <= 0) { // La balle touche le sol
      ball.position.z  = 0.5; // La balle ne passe pas sous le sol
      velocity.z  = -velocity.z  * restitution; // Inverser la vitesse et appliquer le coefficient de restitution
    }
  
    // Gérer la friction horizontale (ralentissement)
    velocity.x *= damping;
    velocity.y *= damping;
  }

const ballBoundingSphere = new THREE.Sphere(ball.position, 1);  
let carBoundingBox = new THREE.Box3();


function updateBoundingBox() {
    if (carModel) {
        carBoundingBox.setFromObject(carModel);
    }
}

// Collision detection function
function detectCollisions() {
    updateBoundingBox();

    if (carBoundingBox.intersectsSphere(ballBoundingSphere)) {
        console.log('Collision Detected!');

        const collisionNormal = new THREE.Vector3().subVectors(ball.position, carModel.position).normalize();
        ball.position.add(collisionNormal.multiplyScalar(0.1));
    }
}
  // Fonction d'animation
  function animate() {
    requestAnimationFrame(animate);
    moveCar();
    // effet de rotation
    ball.rotation.x += 0.01;
    ball.rotation.y += 0.01;

    const elapsedTime = clock.getElapsedTime();
    grassUniforms.iTime.value = elapsedTime;

    updateBallPhysics()
    detectCollisions();
    refreshCameraPosition();

    renderer.render(scene, camera);
  }

  animate();

  document.addEventListener('keydown', (event) => {
    keyStates[ event.code ] = true;
    if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.code)) {
      event.preventDefault(); // Empêche le défilement de la page ou le mouvement de la caméra par défaut
    }
  });
  document.addEventListener( 'keyup', ( event ) => {
    keyStates[ event.code ] = false;
  });

  // Ajuster le rendu lors du redimensionnement de la fenêtre
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>
